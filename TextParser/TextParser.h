#ifndef __TEXTPARSER__H__
#define __TEXTPARSER__H__

class CTextParser
{
private :
	/*--------------------------------------------------------------------*/
	// 파서에서 쓰일 토큰들
	//
	// 컴마				,
	// 마침표			.
	// 쌍따옴표			"
	// 스페이스			0x20
	// 백스페이스		0x08
	// 탭				0x09
	// 라인피드			0x0a
	// 캐리지 리턴		0x0d
	// 공백				0x20
	/*--------------------------------------------------------------------*/
	enum e_TEXT_TOKEN
	{
		eTOKEN_COMMA			= ',',
		eTOKEN_PERIOD			= '.',
		eTOKEN_QUOTATION_MARK	= '"',
		eTOKEN_SPACE			= 0x20,
		eTOKEN_BACKSPACE		= 0x08,
		eTOKEN_TAB				= 0x09,
		eTOKEN_LINEFEED			= 0x0a,
		eTOKEN_CARRIAGE_RETURN	= 0x0d,
		eTOKEN_BLANK			= 0x20
	};

	enum e_INIT
	{
		eMAX_FILE_BUFFER		= 102400,
		eMAX_FIELD_LENGTH		= 256
	};

public :
	////////////////////////////////////////////////////////////////////////
	// 생성자
	////////////////////////////////////////////////////////////////////////
	CTextParser()
	{
		_chpBuffer = new char[eMAX_FILE_BUFFER];

		_iDataSize = 0;

		_iBufferZoneStart = -1;
		_iBufferZoneEnd = -1;
		_iBufferCurrentPos = 0;
	}


	////////////////////////////////////////////////////////////////////////
	// 소멸자
	////////////////////////////////////////////////////////////////////////
	virtual		~CTextParser()
	{
		delete[] _chpBuffer;
	}

	////////////////////////////////////////////////////////////////////////
	// 파일 로드
	////////////////////////////////////////////////////////////////////////
	bool		LoadFile(char *pFileName)
	{
		HANDLE	hFile;
		DWORD	dwReadSize;

		WCHAR	*wpFileName;

		int strSize = MultiByteToWideChar(CP_ACP, 0, pFileName, -1, NULL, NULL);
		wpFileName = new WCHAR[strSize];

		MultiByteToWideChar(CP_ACP, 0, pFileName, strlen(pFileName) + 1, wpFileName, strSize);


		hFile = CreateFile(wpFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (INVALID_HANDLE_VALUE == hFile)
			return false;
		

		_iDataSize = GetFileSize(hFile, NULL);

		if (eMAX_FILE_BUFFER < _iDataSize)
		{
			CloseHandle(hFile);

			return false;
		}

		ReadFile(hFile, _chpBuffer, _iDataSize, &dwReadSize, NULL);
		if (dwReadSize != _iDataSize)
		{
			CloseHandle(hFile);

			return false;
		}

		CloseHandle(hFile);

		return true;
	}


	////////////////////////////////////////////////////////////////////////
	// 구역 찾기
	////////////////////////////////////////////////////////////////////////
	bool SearchZone(char *pZoneName)
	{
		char	*chpBuf, chBuf[eMAX_FIELD_LENGTH];
		int		iWordLength;
		bool	bIsZone		= false;

		////////////////////////////////////////////////////////////////////
		// 새 구역 설정을 위해 초기화
		////////////////////////////////////////////////////////////////////
		_iBufferZoneStart	= -1;
		_iBufferZoneEnd		= -1;

		_iBufferCurrentPos	= 0;

		////////////////////////////////////////////////////////////////////
		// 단어 단위로 찾기
		////////////////////////////////////////////////////////////////////
		while (GetNextWord(&chpBuf, &iWordLength))
		{
			memset(chBuf, 0, eMAX_FIELD_LENGTH);
			memcpy(chBuf, chpBuf, iWordLength);

			////////////////////////////////////////////////////////////////
			// 구역의 시작을 찾음 -> :
			////////////////////////////////////////////////////////////////
			if (':' == chBuf[0])
			{
				////////////////////////////////////////////////////////////
				// 구역시작점(:) 다음의 이름 비교
				////////////////////////////////////////////////////////////
				if (0 == strcmp(pZoneName, chBuf + 1))
				{
					////////////////////////////////////////////////////////
					// 구역이름 다음 구분자가 있는지 확인
					////////////////////////////////////////////////////////
					if (GetNextWord(&chpBuf, &iWordLength))
					{
						memset(chBuf, 0, eMAX_FIELD_LENGTH);
						memcpy(chBuf, chpBuf, iWordLength);

						if ('{' == chBuf[0])
						{
							////////////////////////////////////////////////
							// 공백 제거
							////////////////////////////////////////////////
							if (!SkipNoneCommand())
							{
								return false;
							}

							////////////////////////////////////////////////
							// 찾은 구역의 시작 위치 저장
							////////////////////////////////////////////////
							_iBufferZoneStart = _iBufferCurrentPos;
							bIsZone = true;
						}

						////////////////////////////////////////////////////
						// 구분자가 없을 때
						////////////////////////////////////////////////////
						else
						{
							return false;
						}
					}
				}
			}


			////////////////////////////////////////////////////////////
			// 구역 시작점, 이름, 구분자(시작)이 완료됐으면
			// 구역 끝을 찾아서 끝 위치 저장
			////////////////////////////////////////////////////////////
			if (bIsZone && (chBuf[0] == '}'))
			{
				_iBufferZoneEnd = _iBufferCurrentPos - 1;

				return true;
			}
		}

		return false;
	}


	////////////////////////////////////////////////////////////////////////
	// 토큰 처리
	////////////////////////////////////////////////////////////////////////
	bool		SkipNoneCommand(void)
	{
		char *chpBuffer;

		chpBuffer = _chpBuffer + _iBufferCurrentPos;
		
		while (1)
		{
			////////////////////////////////////////////////////////////////
			// 파일의 끝
			////////////////////////////////////////////////////////////////
			if (_iBufferCurrentPos > _iDataSize)
				return false;

			////////////////////////////////////////////////////////////////
			// 백스페이스, 탭, 라인피드, 캐리지리턴, 공벽
			////////////////////////////////////////////////////////////////
			if (eTOKEN_BACKSPACE == *chpBuffer ||
				eTOKEN_TAB == *chpBuffer ||
				eTOKEN_LINEFEED == *chpBuffer ||
				eTOKEN_CARRIAGE_RETURN == *chpBuffer ||
				eTOKEN_BLANK == *chpBuffer)
			{
				*chpBuffer = eTOKEN_BLANK;

				chpBuffer++;
				_iBufferCurrentPos++;
			}

			////////////////////////////////////////////////////////////////
			// 주석 (//) 체크
			////////////////////////////////////////////////////////////////
			else if (('/' == *chpBuffer) && ('/' == *(chpBuffer + 1)))
			{
				////////////////////////////////////////////////////////////
				// 엔터 나오기 전까진 주석 부분
				////////////////////////////////////////////////////////////
				while (eTOKEN_CARRIAGE_RETURN != *chpBuffer)
				{
					////////////////////////////////////////////////////////
					// 주석부분 넘어가기
					////////////////////////////////////////////////////////
					_iBufferCurrentPos++;
					chpBuffer++;

					////////////////////////////////////////////////////////
					// 파일의 끝
					////////////////////////////////////////////////////////
					if (_iBufferCurrentPos > _iDataSize)
						return false;
				}
			}

			////////////////////////////////////////////////////////////////
			// 주석 (/* ~ */) 체크
			////////////////////////////////////////////////////////////////
			else if (('/' == *chpBuffer) && ('*' == *(chpBuffer + 1)))
			{
				////////////////////////////////////////////////////////////
				// */ 나오기 전까지는 전부 주석
				////////////////////////////////////////////////////////////
				while (!(('*' == *chpBuffer) && ('/' == *(chpBuffer + 1))))
				{
					_iBufferCurrentPos++;
					chpBuffer++;

					////////////////////////////////////////////////////////
					// 파일의 끝
					////////////////////////////////////////////////////////
					if (_iBufferCurrentPos > _iDataSize)
						return false;
				}

				////////////////////////////////////////////////////////////
				// */ 뒤 만큼 더 이동시켜 줌
				////////////////////////////////////////////////////////////
				_iBufferCurrentPos += 2;
			}

			else		break;
		}

		return true;
	}


	////////////////////////////////////////////////////////////////////////
	// 다음 단어 얻기
	////////////////////////////////////////////////////////////////////////
	bool		GetNextWord(char **chppBuffer, int *ipLength)
	{
		char *chpBufferWord;

		////////////////////////////////////////////////////////////////////
		// 공백 제거
		////////////////////////////////////////////////////////////////////
		if (!SkipNoneCommand())
			return false;

		////////////////////////////////////////////////////////////////////
		// 단어 시작점 저장
		////////////////////////////////////////////////////////////////////
		*chppBuffer = _chpBuffer + _iBufferCurrentPos;
		chpBufferWord = *chppBuffer;

		*ipLength = 0;

		////////////////////////////////////////////////////////////////////
		// 첫 문자가 "면 문자열로 읽음
		////////////////////////////////////////////////////////////////////
		if ('"' == **chppBuffer)
		{
			if (GetStringWord(chppBuffer, ipLength))
				return true;

			else		return false;
		}

		while (1)
		{
			////////////////////////////////////////////////////////////////
			// 토큰 기준으로 단어 끝으로 오면 정지
			////////////////////////////////////////////////////////////////
			if (eTOKEN_SPACE			== *chpBufferWord ||
				eTOKEN_COMMA			== *chpBufferWord ||
				eTOKEN_BACKSPACE		== *chpBufferWord ||
				eTOKEN_TAB				== *chpBufferWord ||
				eTOKEN_LINEFEED			== *chpBufferWord ||
				eTOKEN_CARRIAGE_RETURN	== *chpBufferWord)
				break;

			////////////////////////////////////////////////////////////////
			// 위치, 단어 한칸 이동, 길이 더하기 1
			////////////////////////////////////////////////////////////////
			_iBufferCurrentPos++;
			chpBufferWord++;
			(*ipLength)++;

			////////////////////////////////////////////////////////////////
			// 파일의 끝
			////////////////////////////////////////////////////////////////
			if (_iBufferCurrentPos > _iDataSize)
				break;
		}

		////////////////////////////////////////////////////////////////////
		// 길이가 0이면 error
		////////////////////////////////////////////////////////////////////
		if (0 == (*ipLength))
			return false;

		return true;
	}


	////////////////////////////////////////////////////////////////////////
	// 문자열 얻기
	////////////////////////////////////////////////////////////////////////
	bool		GetStringWord(char **chppBuffer, int *ipLength)
	{
		char *chpBufferString;

		////////////////////////////////////////////////////////////////////
		// 첫 문자가 " 인지 확인
		////////////////////////////////////////////////////////////////////
		if ('"' != **chppBuffer)
			return false;

		////////////////////////////////////////////////////////////////////
		// 처음 따옴표 버리기
		////////////////////////////////////////////////////////////////////
		_iBufferCurrentPos++;

		*chppBuffer = _chpBuffer + _iBufferCurrentPos;
		chpBufferString = *chppBuffer;

		while (1)
		{
			////////////////////////////////////////////////////////////////
			// 따옴표, 엔터코드 확인
			////////////////////////////////////////////////////////////////
			if ('"'						== *chpBufferString ||
				eTOKEN_LINEFEED			== *chpBufferString ||
				eTOKEN_CARRIAGE_RETURN	== *chpBufferString)
			{
				_iBufferCurrentPos++;
				break;
			}

			////////////////////////////////////////////////////////////////
			// 위치, 단어 한칸 이동, 길이 더하기 1
			////////////////////////////////////////////////////////////////
			_iBufferCurrentPos++;
			chpBufferString++;
			(*ipLength)++;

			////////////////////////////////////////////////////////////////
			// 파일의 끝
			////////////////////////////////////////////////////////////////
			if (_iBufferCurrentPos > _iDataSize)
				break;
		}

		////////////////////////////////////////////////////////////////////
		// 문자열은 길이가 0인 경우도 있다 
		// ex ) ""
		////////////////////////////////////////////////////////////////////
		return true;
	}


	////////////////////////////////////////////////////////////////////////
	// 값을 얻기
	////////////////////////////////////////////////////////////////////////
	bool		GetValue(char *pField, int *ipValue)
	{
		char *chpBuf, chBuf[eMAX_FIELD_LENGTH];
		int iLength;

		////////////////////////////////////////////////////////////////////
		// 찾은 구역 시작으로 이동
		////////////////////////////////////////////////////////////////////
		_iBufferCurrentPos = _iBufferZoneStart;


		////////////////////////////////////////////////////////////////////
		// 필드 찾기
		////////////////////////////////////////////////////////////////////
		while (GetNextWord(&chpBuf, &iLength))
		{
			memset(chBuf, 0, eMAX_FIELD_LENGTH);
			memcpy(chBuf, chpBuf, iLength);

			////////////////////////////////////////////////////////////////
			// 필드 맞는지 봄
			////////////////////////////////////////////////////////////////
			if (0 == strcmp(pField, chBuf))
			{
				if (GetNextWord(&chpBuf, &iLength))
				{
					memset(chBuf, 0, eMAX_FIELD_LENGTH);
					memcpy(chBuf, chpBuf, iLength);

					////////////////////////////////////////////////////////
					// = 맞는지 보기
					////////////////////////////////////////////////////////
					if (0 == strcmp(chBuf, "="))
					{
						if (GetNextWord(&chpBuf, &iLength))
						{
							memset(chBuf, 0, eMAX_FIELD_LENGTH);
							memcpy(chBuf, chpBuf, iLength);

							*ipValue = atoi(chBuf);
							return true;
						}

						return false;
					}
				}

				return false;
			}
		}

		return false;
	}

	bool		GetValue(char *pField, float *ipValue)
	{
		char *chpBuf, chBuf[eMAX_FIELD_LENGTH];
		int iLength;

		////////////////////////////////////////////////////////////////////
		// 찾은 구역 시작으로 이동
		////////////////////////////////////////////////////////////////////
		_iBufferCurrentPos = _iBufferZoneStart;


		////////////////////////////////////////////////////////////////////
		// 필드 찾기
		////////////////////////////////////////////////////////////////////
		while (GetNextWord(&chpBuf, &iLength))
		{
			memset(chBuf, 0, eMAX_FIELD_LENGTH);
			memcpy(chBuf, chpBuf, iLength);

			////////////////////////////////////////////////////////////////
			// 필드 맞는지 봄
			////////////////////////////////////////////////////////////////
			if (0 == strcmp(pField, chBuf))
			{
				if (GetNextWord(&chpBuf, &iLength))
				{
					memset(chBuf, 0, eMAX_FIELD_LENGTH);
					memcpy(chBuf, chpBuf, iLength);

					////////////////////////////////////////////////////////
					// = 맞는지 보기
					////////////////////////////////////////////////////////
					if (0 == strcmp(chBuf, "="))
					{
						if (GetNextWord(&chpBuf, &iLength))
						{
							memset(chBuf, 0, eMAX_FIELD_LENGTH);
							memcpy(chBuf, chpBuf, iLength);

							*ipValue = (float)atof(chBuf);
							return true;
						}

						return false;
					}
				}

				return false;
			}
		}

		return false;
	}

	bool		GetValue(char *pField, char *pValue, int *ipBufSize)
	{
		char *chpBuf, chBuf[eMAX_FIELD_LENGTH];
		int iLength;

		////////////////////////////////////////////////////////////////////
		// 찾은 구역 시작으로 이동
		////////////////////////////////////////////////////////////////////
		_iBufferCurrentPos = _iBufferZoneStart;


		////////////////////////////////////////////////////////////////////
		// 필드 찾기
		////////////////////////////////////////////////////////////////////
		while (GetNextWord(&chpBuf, &iLength))
		{
			memset(chBuf, 0, eMAX_FIELD_LENGTH);
			memcpy(chBuf, chpBuf, iLength);

			////////////////////////////////////////////////////////////////
			// 필드 맞는지 봄
			////////////////////////////////////////////////////////////////
			if (0 == strcmp(pField, chBuf))
			{
				if (GetNextWord(&chpBuf, &iLength))
				{
					memset(chBuf, 0, eMAX_FIELD_LENGTH);
					memcpy(chBuf, chpBuf, iLength);

					////////////////////////////////////////////////////////
					// = 맞는지 보기
					////////////////////////////////////////////////////////
					if (0 == strcmp(chBuf, "="))
					{
						if (GetNextWord(&chpBuf, &iLength))
						{
							////////////////////////////////////////////////
							// 문자열 다 못받는 경우
							////////////////////////////////////////////////
							if (*ipBufSize <= iLength)
								return false;

							memset(pValue, 0, *ipBufSize);
							memcpy(pValue, chpBuf, iLength);

							*ipBufSize = iLength;
							return true;
						}

						return false;
					}
				}

				return false;
			}
		}

		return false;
	}




private :
	////////////////////////////////////////////////////////////////////////
	// 전체 버퍼
	////////////////////////////////////////////////////////////////////////
	char			*_chpBuffer;


	////////////////////////////////////////////////////////////////////////
	// 전체 데이터 사이즈
	////////////////////////////////////////////////////////////////////////
	int				_iDataSize;


	////////////////////////////////////////////////////////////////////////
	// 구역 시작과 끝, 현재 위치
	////////////////////////////////////////////////////////////////////////
	int				_iBufferZoneStart;
	int				_iBufferZoneEnd;
	int				_iBufferCurrentPos;
};

#endif